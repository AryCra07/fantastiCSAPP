## 2.3	整数运算

### 2.3.1	无符号加法

我们将操作 $+^u_w$描述为整数和 $x+y$ 截断为 $w$ 位的结果 ：

 对满足 $0 \leq x,y<2^w$ 的 $x$ 和 $y$ 有：

$$x+^u_wy=\begin{cases}x+y,\quad x+y< 2^w(正常) \\x+y-2^w,\quad 2^w\leq x+y\leq 2^{w+1}(溢出) \end{cases}$$

*当 $x+y<2^w$ 时，和的$2^{w+1}$ 位即最高位为0，所以丢弃它并不会影响结果。当 $x+y$  的值超过这个值（即溢出）时，和的$2^{w+1}$ 为1，而丢弃它就等价于从和中减去$2^w$。* 说一个算术运算溢出，是指完整的整数不能放到数据类型的字长限制中。

C 语言怎么检测溢出呢？

```c
// 0 <= x, y <= UMax_w
int isOverflow(unsigned int x, unsigned int y) {
    unsigned res = x + y;
    return res < x; // or res < y
}
```

*看一眼最初的公式中 x 和 y 的取值，我们会发现正常情况下必定有 `res >= x && res >= y`，而在溢出时，由于`x < pow(2, w) && y < pow(2, w)`，所以与 x 或 y 相加的必定是个负数，即 `res < x && res < y`。*

#### 原理：无符号数求反

当 $x=0$ 时，对满足 $0\leq x<2^w$ 的任意 $x$，其 $w$ 位的无符号逆元 $-^u_wx$ 由下式给出：

$$-^u_wx=\begin{cases}x,\quad x=0 \\2^w-x,\quad x>0 \end{cases}$$

*$(x+2^w-x)$ mod $2^w$ = $2^w$ mod $2^w$ = 0*

### 2.3.2	补码加法

#### 原理：补码加法

对满足 $-2^{w-1}\leq x,y\leq 2^{w-1}-1$ 的整数 $x$ 和 $y$，有：

$$x+^u_wy=\begin{cases}x+y-2^w,\quad 2^{w-1}\leq x+y（正溢出） \\x+y,\quad -2^{w-1} \leq x+y\leq 2^{w-1} (正常) \\ x+y+2^w, \quad x + y<-2^{w-1}(负溢出) \end{cases}$$

*既然补码加法与无符号数加法有相同的位级表示，我们就可以按如下步骤表示运算$+^t_w$：将其参数转换为无符号数，执行无符号数加法，再将结果转换为补码：*

$$x+^t_wy\doteq U2T_w(T2U_w(x)+^u_wT2U_w(y))$$

由之前内容，$$T2U_w(x)=x_{w-1}2*w+x$$

**一个值得注意的结论是， `x >> k` 等价于 `x / 2^k`，`x << k` 等价于 `x * 2^k`**

### 2.3.3	补码的非

可以看到范围在 $TMin_w\leq x\leq TMax_w$ 中的每个数字 $x$ 都有 $+^t_w$ 下的加法逆元，我们将其令为 $-^t_wx$ 并表示如下：

#### 原理：补码的非

对满足 $TMin_w\leq x\leq TMax_w$ 的 $x$，其补码的非 $-^t_wx$ 由下式给出

$$-^t_wx=\begin{cases}TMin_w,\quad x=TMin_w\\-x,\quad x > TMin_w \end{cases}$$

*当 $x=TMin_w$ 的时候，它的逆也是 $TMin_w$，加起来的进位正好溢出了，后边全是0，因此等于0。*

**Note 补码非的位级表示：** 计算一个位级表示的值有几种聪明的办法

- 第一种方法是对每一位求补，再对结果加 1。在 C 语言中我们可以说，对于任意整数值 x，计算 -x 与 ~x + 1 得到的结果完全一样。
- 第二种方法建立在将位向量分为两部分的基础之上的。假设 k 是最右边的 1 的位置，我们将 k 左边的所有位取反，即获得了补码非。

### 2.3.4	无符号乘法

范围在 $0\leq x,y\leq 2^w-1$ 内的整数 $x$ 和 $y$ 可以被表示为 $w$ 位的无符号数，但是它们的乘积 $x\bullet y$ 的取值范围为 0 到 $(2^w-1)=2^{2w}-2^{w+1}+1$ 之间，这可能需要 $2w$ 位来表示。不过 C 语言中的无符号乘法被定义为产生 w 位的值，就是 2w 位的整数乘积的低 w 位表示的值。我们将这个值表示为 $x*^u_wy$。

将一个无符号数截断为产生 w 位等价于计算该值模 $2^w$，得到：

#### 原理：无符号数乘法

对满足 $0\leq x,y\leq UMax_w$ 的 $x$ 和 $y$ 有：

$$x*^u_wy=(x\bullet y)\;mod\;2^w$$

###	2.3.5 补码乘法

范围在 $-2^{w-1}\leq x,y\leq 2^{w-1}-1$ 内的整数 x 和 y 可以被表示为 w 位的补码数字，但是它们的乘积 $x\bullet y$ 的取值范围为 $-2^{w-1}\bullet (2^{w-1}-1)=-2^{2w-2}+2^{w-1}$ 到 $-2^{w-1}\bullet -2^{w-1}=2^{2w-2}$ 之间。要想用补码来表示这个乘积，我们可能需要 $2w$ 位。然而，C 语言中的有符号乘法是通过将 $2w$ 位的乘积截断为 $w$ 位来实现的。我们将这个数值表示为 $x*{^t_w}y$ ，相当于先计算该值模 $2^w$，再把无符号数转换成补码，得到：

#### 原理：补码乘法

对满足 $TMin_w\leq x,y\leq TMax_w$ 的 $x$ 和 $y$ 有：

$$x*^t_w{y}=U2T_w((x\bullet y)\: mod\: 2^w)$$

#### 原理：无符号数与补码乘法的位级等价性

给定长度为 $w$ 的位向量 $\vec{x}$ 和 $\vec{y}$，用补码形式的位向量表示来定义整数 $x$ 和 $y$：$x=B2T_w(\vec{x})$，$y=B2T_w(\vec{y})$。用无符号形式的位向量表示来定义非负整数 $x'$ 和 $y'$：$x'=B2U_w(\vec{x})$，$y'=B2U_w(\vec{y})$。则

$$T2B_w(x*^t_wy)=U2B_w(x'*^u_w y')$$

**推导：** 无符号和补码乘法的位级等价性

由之前公式我们得 $x'=x+x_{w-1}2^w$ 和 $y'=y+y_{w-1}2^w$。计算这两个值的乘积并模 $2^w$ 将会得到以下结果：

$$(x'\bullet y')\: mod\: 2^w=[(x+x_{w-1}2^w)+(y+y_{w-1}2^w)]\: mod\: 2^w=(x\bullet y)\: mod\: 2^w$$

### 2.3.6	乘以常数

以往，在大多数机器上，整数乘法指令非常慢，需要 10 个或者更多的时钟周期，然而其他整数运算（加法、减法、位级交流和移位等操作）只需要 1 个时钟周期。因此，编译器使用了**一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法**。首先，我们会考虑乘以 2 的幂的情况，然后再概括成乘以任意常数。

#### 原理：乘以 2 的幂

设 $x$ 为位模式 $[x_{w-1},x_{w-2},...,x_0]$ 表示的无符号整数。那么，对于任何 $k\geq 0$，我们都认为 $[x_{w-1},x_{w-2},...,x_0,0,...,0]$ 给出了 $x2^k$ 的 $w+k$ 位的无符号表示，这里右边增加了 $k$ 个 0。

#### 原理：与 2 的幂相乘的无符号乘法

C 变量 `x` 和 `k` 有无符号数值 $x$ 和 $k$，且 $0\leq k<w$，则 C 表达式 `x << k`  产生数值 $x*^u_w2^k$。

**由于我们之前已经证明，固定大小的补码算数运算的位级操作与其无符号运算等价，我们就可以对补码运算的 2 的幂的乘法与左移之间的关系进行类似的表述：**

#### 原理：与 2 的幂相乘的无符号乘法

C 变量 `x` 和 `k` 有补码值 $x$ 和无符号数值 $k$，且 $0\leq k<w$，则 C 表达式 `x << k`  产生数值 $x*^t_w2^k$。

*注意，无论是无符号运算还是补码运算，乘以 2 的幂都可能导致溢出，而即使在溢出的时候，我们通过移位的结果也是一样的。*

**那么当乘以不是 2 的幂的常数呢？** 例如 `x * 14`，编译器会将 14 优化成 `(x << 3) + (x << 2) + (x << 1)` 或 `(x << 4) - (x << 1)`。

### 2.3.7	除以 2 的幂

—— 在大多数机器上，整数除法比整数乘法更慢。

除以 2 的幂也可以移位运算来实现，只不过我们用的是右移而非左移。无符号和有符号码数分别通过逻辑移位和算数移位来达到目的。

整数除法总是舍入到零，所以我们引入一些符号来准确定义，例如高斯函数中的 $\lfloor a\rfloor$ 和 $\lceil a\rceil$。

对无符号运算使用移位是非常简单的，部分原因是由于无符号数的右移一定是逻辑右移。

**原理：** 除以 2 的幂的无符号除法

C 变量 `x` 和 `k` 有无符号值 $x$ 和 $k$，且 $0\le k<w$，则 C 表达式 `x >> k` 产生数值 $\lfloor x/2^k \rfloor$。

**原理：** 除以 2 的幂的补码除法，向下舍入

C 变量 `x` 和 `k` 分别有补码值 $x$ 和无符号数值 $k$，且 $0\le k\le w$，则当执行算数移位时，C 表达式 `x >> k` 产生数值 $\lfloor x/2^k \rfloor$。

**原理：** 除以 2 的幂的补码除法，向上舍入

C 变量 `x` 和 `k` 分别有补码值 $x$ 和无符号数值 $k$，且 $0\le k\le w$，则当执行算数移位时，C 表达式 $(x+(1<<k)-1)>>k$ 产生数值 $\lceil x/2^k\rceil$。

### 2.3.8 关于整数运算的最后思考

**以有限追求无限** —— 正如我们看到的，计算机执行的 “整数” 运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。我们还看到，补码表示提供了一种既能表示负数也能表示正数的灵活方法，**同时使用了与执行无符号运算相同的位级实现**。补码和无符号数绝大部分区别在于解释方式，而非位级行为。
