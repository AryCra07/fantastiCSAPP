## 2.2	整数表示

在本节中，我们描述用位来编码整数的两种不同的方式

- 一种只能表示非负整数

- 一种能够表示负数、零和正数

![](/notes/img/2.4.png)

### 2.2.1	整形数据类型

C 语言支持多种**整形**数据类型——表示有限范围的整数。

![](/notes/img/2.5.png)

![](/notes/img/2.6.png)

*值得注意的是，每种数据类型的取值范围都不是对称的——负数的取值范围比整数的范围大1。*

C 语言定义了每种数据类型必须能够表示的最小取值范围

![](/notes/img/2.7.png)

### 2.2.2	无符号数的编码

我们把 $\vec{x}$ 看做一个二进制表示的有 $w$ 位的数，$[x_{w-1}, x_{w-2}, ...,x_0]$ 表示向量中的每一位。

其中，每个位 $x_i$ 都取值为 0 或 1，它们对应的权重是 $2^i$。当该位取值为 1 的时候，我们就将 $2^i$ 作为最终数字的一部分。

于是我们就获得了 $\vec{x}$ 的无符号表示：

$$B2U_w(\vec{x})\doteq \sum_{i=0}^{w-1}x_i2^i$$

不难得出 $UMAX_x\doteq 2^w-1$。

**无符号数的二进制表示有一个很重要的属性，每个介于 0~$2^w$-1的数都有唯一一个 $w$ 位的值编码。即函数$B2U_w$是一个双射。**

### 2.2.3	补码编码

对于很多应用，我们还希望表示负数值，最常见的有符号数的表示形式就是**补码形式**。在补码定义中，我们将字的最高有效位的权重定义为负权。参见 2.2.2 的表示形式，我们有：

$$B2T_w(\vec{x})\doteq -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$$

不难得出 $TMAX_{w}\doteq 2^{w-1}-1$,$TMIN_w\doteq 2^{w-1}$。

最高有效位也称**符号位**，它的权重为 $-2^{w-1}$，是无符号表示中权重的负数。**这也是它和无符号数编码的主要差别。**

**补码编码同样具有唯一性，即函数$B2T_w$是一个双射。**

### 2.2.4	有符号数与无符号数之间的转换

#### 补码转换成无符号数

$$T2U_w(x)=\begin{cases}x,\quad x\geq 0\\x+2^w,\quad x<0 \end{cases}$$

*当 x < 0 时，$2^{w-1}$ 位的权重正好一正一负，因此相差 $2^w$。* 

#### 无符号数转换为补码

$$U2T_w(u)=\begin{cases}u,\quad u\leq TMax_w \\u-2^w,\quad x>TMax_w \end{cases}$$

*易得此操作是补码转换成无符号数的反向操作，在最高位的权重为 0 时，无符号数与补码的解释方式相同，否则权重一正一负，相差 $2^w$*

### 2.2.5	C 语言中的有符号数与无符号数

C 语言支持所有整型数据类型的有符号与无符号运算，并且几乎所有机器都使用补码来表示有符号数。大多数数字都被认为是有符号数，例如 12345 与 0x1a1a。要创建一个无符号常量，必须加上后缀 'U' 或 'u'。

C 语言支持有符号数与无符号数的转换。虽然 C 标准没有精确规定转换方式，但大多数系统遵循的是底层的位保持不变。**即在转换中，改变的是对位的解释方式而非真正的位。** 

当执行一个运算时如果同时出现有符号数与无符号数，则 C 语言会隐式地将有符号数强制转换为无符号数。

### 2.2.6	扩展一个数字的位表示

#### 无符号数的零扩展

定义宽度为 $w$  的位向量 $\vec{u}=[u_{w-1},u_{w-2},...,u_0]$和宽度为 $w'$ 的位向量 $\vec{u'}=[0,...,u_{w-1},u_{w-2},...,u_0]$，其中 $w'>w$。则$B2U_w(\vec{u})=B2U_{w'}(\vec{u'})$。

#### 补码数的符号扩展

定义宽度为 $w$  的位向量 $\vec{x}=[x_{w-1},x_{w-2},...,x_0]$和宽度为 $w'$ 的位向量 $\vec{x'}=[x_{w-1},...,x_{w-1},x_{w-2},...,x_0]$，其中 $w'>w$。则 $B2T_w(\vec{x})=B2T_{w'}(\vec{x'})$。

*这个怎么推导呢？可以用归纳法。*

- 当 $w'=w+1$ 时，$\vec{x'}$ 前两项为$(-2^{w}+2^{w-1})\times x_{w-1}=-2^{w-1}\times x_{w-1}$*，即 $\vec{x}$ 的第一项。所以可得此时 $B2T_w(\vec{x})=B2T_{w'}(\vec{x'})$。
- 依次类推，当 $w'=w+2$ 时，我们可以考虑 $w+1$ 和$w+2$ 之间的关系，得出的结论同上。直至归纳结束，都有 $B2T_w(\vec{x})=B2T_{w'}(\vec{x'})$ 成立。故此结论正确。

### 2.2.7	截断数字

假如我们如下面代码所示减少表示一个数字的位数：

```c
int x = 53191;
short sx = (short) x; // -12345
int y = sx; // -12345
```

#### 截断无符号数

令 $\vec{x}$ 等于位向量 $[x_{w-1},x_{w-2},...,x_0]$，而 $\vec{x}$ 是将其截断为 $k$ 位的结果，则 $\vec{x'}=[x_{k-1},x_{k-2},...,x_0]$。令 $x=B2U_w(\vec{x})$，$x'=B2U_k(\vec{x'})$，则 $x'$ = $x$ mod $2^k$。

*如果你能理解十进制的 mod 操作，那么这里的操作也非常容易理解——十进制下，我们想将四位数（比如1234）截断成三位数，办法就是 mod $10^3=1000$，得到截断后的三位数（234）。*

#### 截断补码数值

令 $\vec{x}$ 等于位向量 $[x_{w-1},x_{w-2},...,x_0]$，而 $\vec{x}$ 是将其截断为 $k$ 位的结果，则 $\vec{x'}=[x_{k-1},x_{k-2},...,x_0]$。令 $x=B2T_w(\vec{x})$，$x'=B2T_k(\vec{x'})$，则 $x'$ = $U2T_k$($x$ mod $2^k$)。

总结就是，截断操作都是一样的拦腰截断操作，无符号数和补码结果的区别在于其解释方式不同。

### 2.2.8	关于有符号数与无符号数的建议

有符号数到无符号数的隐式强制类型转换导致了某些非直观行为。