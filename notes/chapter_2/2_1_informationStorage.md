## 2.1 信息存储

- 大多数计算机使用`byte`而非单独的`bit`作为最小可寻址的内存单位，`1 byte = 8 bits`。
- 机器级程序将内存看作一个非常大的字节数组，称为**虚拟内存**。在内存中，每个字节都有唯一的标识数字，称为**地址**，所有可能地址的集合就称为**虚拟地址空间**。
- 系统会将存储器空间划分为更可管理的单元，来存放不同的**程序对象**。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。
  - **程序对象**包括程序数据、指令和控制信息。

### 2.1.1 十六进制表示法

![](/notes/img/2.1.png)

*在C语言中，以0x或0X开头的数字被认为是十六进制数字，字符'A'~'F'大小写不限*

- 进制转换的一个技巧是，记住A/C/F对应的十进制值，B/D/E则通过计算和它们的相对关系来得出。
- **16进制转2进制** 依次展开每个十六进制并进行转换。
- **2进制转16进制** 分为每4位一组再进行转换。如果位数不是4的倍数，在左边用0补齐。

- **10进制转16进制** 使用**`x = q * 16 + r`**，把每次获得的`r`作为最低位数字转化成16进制，再对`q`重复此操作得到新的`r`，直到`q = 0`为止。

### 2.1.2 字数据大小

- 每台计算机都有一个**字长**，指明指针数据的**标称大小**。由于虚拟地址以字为单位编码，所以字长决定的最重要的系统参数是**虚拟地址空间的最大大小**。对于字长为`w`的机器而言，虚拟地址的范围为 $[0,2^w)$, 最多访问 $2^w$ 个字节。
- 大多数 64 位机器向后兼容 32 位机器。

<img src="/notes/img/2.2.png" style="zoom:50%;" />

使用 `int_32`  和  `int_64` 这样确定大小的数据类型是程序员准确控制数据表示的最佳途径。

程序员应该尽可能使自己的程序在不同的机器和编译器上可移植，**可移植性的一个重要方面就是程序对不同数据类型的确切大小不敏感**。

### 2.1.3 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：

- 这个对象的地址是什么——在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。
- 在内存中如何排列这些字节
  - 大端法：最高有效字节在最前面
  - 小端法：最低有效字节在最前面

### 2.1.4 表示字符串

C 语言中字符串被编码为一个以 `null` 字符结尾的字符数组，每个字符都由某个标准编码来表示，最常见的是 ASCII 编码。相同的文本在使用 ASCII 码的任何系统上都将得到相同的结果，与字节顺序与字大小规则无关。因此文本数据比二进制数据具有更强的平台独立性。

### 2.1.5 表示代码

对于同一段代码，不同的机器类型使用不同的且不兼容的指令和编码方式，因此二进制代码很少能够在不同机器和操作系统组合之间移植。**计算机系统的一个基本概念就是，从机器的角度看，程序仅仅是字节序列。**机器没有关于原始源程序的任何信息，除了可能辅助调试的辅助表之外。

### 2.1.6 布尔代数简介

二进制值是计算机编码、存储和操作信息的核心，布尔则通过将逻辑值 TRUE 和 FALSE 编码为二进制 1 和 0，来研究逻辑推理的基本规则。

<img src="/notes/img/2.3.png" style="zoom:50%;" />

### 2.1.7 C语言中的位级运算

C 语言支持位布尔运算：

- `|` 就是 OR
- `&` 就是 AND
- `~` 就是NOT
- `^` 就是 EXCLUSIVE-OR

对于涉及到十六进制和十进制的位级运算，最好的方式是把它们转换为二进制运算，再转换回去。

### 2.1.8 C语言中的逻辑运算

C 语言支持逻辑运算：

- `||` 就是 OR
- `&&` 就是 AND
- `!` 就是 NOT

**尽管看上去很像，但逻辑运算与位运算的功能是完全不同的**

- 逻辑运算认为所有非零参数都表示 TRUE，而参数 0 表示 FALSE，分别返回 1 或者 0，分别表示结果 TRUE 和 FALSE；而位运算只有在特殊情况即参数被限制为 0 或者 1 的时候，才和与其对应的逻辑运算有相同的行为。
- 逻辑运算符 `&&` 和 `||` 与 对应的位级运算 `&` 和 `|` 之间第二个重要区别是，如果通过第一个参数求值就能确定表达式的结果，逻辑运算符就不会对第二个参数求值。例如，表达式 `a && 5 / a`  将不会造成被 0 除的错误。

### 2.1.9 C语言中的移位运算

- **逻辑右移：**在左端补 k 个 0。
- **算术右移：** 在左端补 k 个最高有效位的值。
- 几乎所有编译器/机器组合都会对有符号数使用算数右移；而无符号数必须是逻辑的。
